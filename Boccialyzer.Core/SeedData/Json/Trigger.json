[
  {
    "tgname": "athena_add_address",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_address() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_address() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_address() IS 'Додавання адреси'; CREATE TRIGGER athena_add_address BEFORE INSERT ON public.\"Addresses\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_address();"
  },
  {
    "tgname": "athena_add_addresstype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_addresstype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_addresstype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_addresstype() IS 'Додавання типу адреси'; CREATE TRIGGER athena_add_addresstype BEFORE INSERT ON public.\"AddressTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_addresstype();"
  },
  {
    "tgname": "athena_add_basestation",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_basestation() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_basestation() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_basestation() IS 'Додавання базових станцій'; CREATE TRIGGER athena_add_basestation BEFORE INSERT ON public.\"BaseStations\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_basestation();"
  },
  {
    "tgname": "athena_add_blanktype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_blanktype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_blanktype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_blanktype() IS 'Додавання типу бланку'; CREATE TRIGGER athena_add_blanktype BEFORE INSERT ON public.\"BlankTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_blanktype();"
  },
  {
    "tgname": "athena_add_casetype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_casetype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_casetype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_casetype() IS 'Додавання типу справ'; CREATE TRIGGER athena_add_casetype BEFORE INSERT ON public.\"CaseTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_casetype();"
  },
  {
    "tgname": "athena_add_codexarticle",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_codexarticle() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_codexarticle() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_codexarticle() IS 'Додавання статті ККУ'; CREATE TRIGGER athena_add_codexarticle BEFORE INSERT ON public.\"CodexArticles\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_codexarticle();"
  },
  {
    "tgname": "athena_add_codexpart",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_codexpart() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_codexpart() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_codexpart() IS 'Додавання розділів ККУ'; CREATE TRIGGER athena_add_codexpart BEFORE INSERT ON public.\"CodexParts\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_codexpart();"
  },
  {
    "tgname": "athena_add_codexsubarticle",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_codexsubarticle() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_codexsubarticle() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_codexsubarticle() IS 'Додавання частини статі ККУ'; CREATE TRIGGER athena_add_codexsubarticle BEFORE INSERT ON public.\"CodexSubArticles\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_codexsubarticle();"
  },
  {
    "tgname": "athena_add_communicationcomplex",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_communicationcomplex() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_communicationcomplex() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_communicationcomplex() IS 'Додавання комплексу'; CREATE TRIGGER athena_add_communicationcomplex BEFORE INSERT ON public.\"CommunicationComplexes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_communicationcomplex();"
  },
  {
    "tgname": "athena_add_communicationtype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_communicationtype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_communicationtype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_communicationtype() IS 'Додавання типу звязку'; CREATE TRIGGER athena_add_communicationtype BEFORE INSERT ON public.\"CommunicationTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_communicationtype();"
  },
  {
    "tgname": "athena_add_courtorder",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_courtorder() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_courtorder() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_courtorder() IS 'Додавання ухвали суду'; CREATE TRIGGER athena_add_courtorder BEFORE INSERT ON public.\"CourtOrders\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_courtorder();"
  },
  {
    "tgname": "athena_add_crime",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_crime() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_crime() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_crime() IS 'Додавання злочину'; CREATE TRIGGER athena_add_crime BEFORE INSERT ON public.\"Crimes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_crime();"
  },
  {
    "tgname": "athena_add_crimetocodex",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_crimetocodex() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_crimetocodex() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_crimetocodex() IS 'Додавання зв’язоку Злочин - Стаття ККУ'; CREATE TRIGGER athena_add_crimetocodex BEFORE INSERT ON public.\"CrimeToCodex\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_crimetocodex();"
  },
  {
    "tgname": "athena_add_department",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_department() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_department() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_department() IS 'Додавання підрозділу'; CREATE TRIGGER athena_add_department BEFORE INSERT ON public.\"Departments\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_department();"
  },
  {
    "tgname": "athena_add_district",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_district() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_district() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_district() IS 'Додавання району'; CREATE TRIGGER athena_add_district BEFORE INSERT ON public.\"Districts\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_district();"
  },
  {
    "tgname": "athena_add_document",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_document() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_document() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_document() IS 'Додавання документу'; CREATE TRIGGER athena_add_document BEFORE INSERT ON public.\"Documents\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_document();"
  },
  {
    "tgname": "athena_add_documenttype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_documenttype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_documenttype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_documenttype() IS 'Додавання типу документа'; CREATE TRIGGER athena_add_documenttype BEFORE INSERT ON public.\"DocumentTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_documenttype();"
  },
  {
    "tgname": "athena_add_email",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_email() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_email() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_email() IS 'Додавання E-mail'; CREATE TRIGGER athena_add_email BEFORE INSERT ON public.\"Emails\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_email();"
  },
  {
    "tgname": "athena_add_eventtypeone",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_eventtypeone() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_eventtypeone() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_eventtypeone() IS 'Додавання типу захода 1'; CREATE TRIGGER athena_add_eventtypeone BEFORE INSERT ON public.\"EventTypesOne\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_eventtypeone();"
  },
  {
    "tgname": "athena_add_eventtypetwo",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_eventtypetwo() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_eventtypetwo() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_eventtypetwo() IS 'Додавання типу захода 2'; CREATE TRIGGER athena_add_eventtypetwo BEFORE INSERT ON public.\"EventTypesTwo\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_eventtypetwo();"
  },
  {
    "tgname": "athena_add_htmltemplate",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_htmltemplate() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_htmltemplate() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_htmltemplate() IS 'Додавання шаблону заявки'; CREATE TRIGGER athena_add_htmltemplate BEFORE INSERT ON public.\"HtmlTemplates\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_htmltemplate();"
  },
  {
    "tgname": "athena_add_imei",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_imei() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_imei() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_imei() IS 'Додавання IMEI'; CREATE TRIGGER athena_add_imei BEFORE INSERT ON public.\"Imeis\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_imei();"
  },
  {
    "tgname": "athena_add_initiatortoissue",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_initiatortoissue() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_initiatortoissue() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_initiatortoissue() IS 'Додавання зв’язоку Ініціатор - Завдання'; CREATE TRIGGER athena_add_initiatortoissue BEFORE INSERT ON public.\"InitiatorToIssues\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_initiatortoissue();"
  },
  {
    "tgname": "athena_add_initiatorrank",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_initiatorrank() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_initiatorrank() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_initiatorrank() IS 'Додавання рангів ініціатора сеансу'; CREATE TRIGGER athena_add_initiatorrank BEFORE INSERT ON public.\"InitiatorRanks\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_initiatorrank();"
  },
  {
    "tgname": "athena_add_interlocutor",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_interlocutor() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_interlocutor() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_interlocutor() IS 'Додавання співрозмовника'; CREATE TRIGGER athena_add_interlocutor BEFORE INSERT ON public.\"Interlocutors\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_interlocutor();"
  },
  {
    "tgname": "athena_add_investigationresult",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_investigationresult() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_investigationresult() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_investigationresult() IS 'Додавання результату розслідування'; CREATE TRIGGER athena_add_investigationresult BEFORE INSERT ON public.\"InvestigationResults\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_investigationresult();"
  },
  {
    "tgname": "athena_add_issue",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_issue() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_issue() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_issue() IS 'Додавання завдання'; CREATE TRIGGER athena_add_issue BEFORE INSERT ON public.\"Issues\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_issue();"
  },
  {
    "tgname": "athena_add_issuecode",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_issuecode() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_issuecode() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_issuecode() IS 'Додавання коду завдання'; CREATE TRIGGER athena_add_issuecode BEFORE INSERT ON public.\"IssueCodes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_issuecode();"
  },
  {
    "tgname": "athena_add_issuestatus",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_issuestatus() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_issuestatus() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_issuestatus() IS 'Додавання статусу завдання'; CREATE TRIGGER athena_add_issuestatus BEFORE INSERT ON public.\"IssueStatuses\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_issuestatus();"
  },
  {
    "tgname": "athena_add_issuestatushistory",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_issuestatushistory() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_issuestatushistory() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_issuestatushistory() IS 'Додавання історії статусів завдань'; CREATE TRIGGER athena_add_issuestatushistory BEFORE INSERT ON public.\"IssueStatusHistories\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_issuestatushistory();"
  },
  {
    "tgname": "athena_add_issuestatustoassignment",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_issuestatustoassignment() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_issuestatustoassignment() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_issuestatustoassignment() IS 'Додавання статусів завдань для розподілу'; CREATE TRIGGER athena_add_issuestatustoassignment BEFORE INSERT ON public.\"IssueStatusToAssignments\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_issuestatustoassignment();"
  },
  {
    "tgname": "athena_add_locality",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_locality() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_locality() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_locality() IS 'Додавання населеного пункту'; CREATE TRIGGER athena_add_locality BEFORE INSERT ON public.\"Localities\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_locality();"
  },
  {
    "tgname": "athena_add_localitytype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_localitytype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_localitytype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_localitytype() IS 'Додавання типу населеного пункту'; CREATE TRIGGER athena_add_localitytype BEFORE INSERT ON public.\"LocalityTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_localitytype();"
  },
  {
    "tgname": "athena_add_mobileoperator",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_mobileoperator() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_mobileoperator() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_mobileoperator() IS 'Додавання оператора звязку'; CREATE TRIGGER athena_add_mobileoperator BEFORE INSERT ON public.\"MobileOperators\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_mobileoperator();"
  },
  {
    "tgname": "athena_add_nationality",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_nationality() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_nationality() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_nationality() IS 'Додавання громадянства'; CREATE TRIGGER athena_add_nationality BEFORE INSERT ON public.\"Nationalities\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_nationality();"
  },
  {
    "tgname": "athena_add_organization",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_organization() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_organization() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_organization() IS 'Додавання організації'; CREATE TRIGGER athena_add_organization BEFORE INSERT ON public.\"Organizations\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_organization();"
  },
  {
    "tgname": "athena_add_parsesetting",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_parsesetting() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_parsesetting() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_parsesetting() IS 'Додавання налаштування парсингу'; CREATE TRIGGER athena_add_parsesetting BEFORE INSERT ON public.\"ParseSettings\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_parsesetting();"
  },
  {
    "tgname": "athena_add_person",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_person() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_person() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_person() IS 'Додавання персони'; CREATE TRIGGER athena_add_person BEFORE INSERT ON public.\"Persons\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_person();"
  },
  {
    "tgname": "athena_add_personalias",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_personalias() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_personalias() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_personalias() IS 'Додавання прізвиська'; CREATE TRIGGER athena_add_personalias BEFORE INSERT ON public.\"PersonAliases\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_personalias();"
  },
  {
    "tgname": "athena_add_persontoimei",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_persontoimei() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_persontoimei() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_persontoimei() IS 'Додавання звязку між персоной та IMEI'; CREATE TRIGGER athena_add_persontoimei BEFORE INSERT ON public.\"PersonToImeis\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_persontoimei();"
  },
  {
    "tgname": "athena_add_persontoperson",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_persontoperson() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_persontoperson() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_persontoperson() IS 'Додавання звязку між персонами'; CREATE TRIGGER athena_add_persontoperson BEFORE INSERT ON public.\"PersonToPeople\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_persontoperson();"
  },
  {
    "tgname": "athena_add_persontosim",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_persontosim() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_persontosim() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_persontosim() IS 'Додавання звязку між персоною та SIM'; CREATE TRIGGER athena_add_persontosim BEFORE INSERT ON public.\"PersonToSims\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_persontosim();"
  },
  {
    "tgname": "athena_add_persontotag",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_persontotag() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_persontotag() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_persontotag() IS 'Додавання звязку між персоною та тегами'; CREATE TRIGGER athena_add_persontotag BEFORE INSERT ON public.\"PersonToTags\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_persontotag();"
  },
  {
    "tgname": "athena_add_position",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_position() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_position() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_position() IS 'Додавання посади співробітників'; CREATE TRIGGER athena_add_position BEFORE INSERT ON public.\"Positions\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_position();"
  },
  {
    "tgname": "athena_add_rank",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_rank() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_rank() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_rank() IS 'Додавання спеціального звання'; CREATE TRIGGER athena_add_rank BEFORE INSERT ON public.\"Rank\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_rank();"
  },
  {
    "tgname": "athena_add_region",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_region() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_region() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_region() IS 'Додавання області'; CREATE TRIGGER athena_add_region BEFORE INSERT ON public.\"Regions\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_region();"
  },
  {
    "tgname": "athena_add_session",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_session() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_session() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_session() IS 'Додавання сеансу'; CREATE TRIGGER athena_add_session BEFORE INSERT ON public.\"Sessions\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_session();"
  },
  {
    "tgname": "athena_add_sessiondescription",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_sessiondescription() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_sessiondescription() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_sessiondescription() IS 'Додавання розшифрування сеансів'; CREATE TRIGGER athena_add_sessiondescription BEFORE INSERT ON public.\"SessionDescriptions\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_sessiondescription();"
  },
  {
    "tgname": "athena_add_sessionrank",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_sessionrank() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_sessionrank() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_sessionrank() IS 'Додавання рангів сеансу'; CREATE TRIGGER athena_add_sessionrank BEFORE INSERT ON public.\"SessionRanks\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_sessionrank();"
  },
  {
    "tgname": "athena_add_sessionstatistic",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_sessionstatistic() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_sessionstatistic() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_sessionstatistic() IS 'Додавання статистики за сеансами'; CREATE TRIGGER athena_add_sessionstatistic BEFORE INSERT ON public.\"SessionStatistic\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_sessionstatistic();"
  },
  {
    "tgname": "athena_add_sessionstatus",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_sessionstatus() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_sessionstatus() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_sessionstatus() IS 'Додавання статусу сеансу'; CREATE TRIGGER athena_add_sessionstatus BEFORE INSERT ON public.\"SessionStatus\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_sessionstatus();"
  },
  {
    "tgname": "athena_add_sessionstatusinitiator",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_sessionstatusinitiator() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_sessionstatusinitiator() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_sessionstatusinitiator() IS 'Додавання статусу сеансу ініціатора'; CREATE TRIGGER athena_add_sessionstatusinitiator BEFORE INSERT ON public.\"SessionStatusInitiators\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_sessionstatusinitiator();"
  },
  {
    "tgname": "athena_add_sim",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_sim() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_sim() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_sim() IS 'Додавання SIM'; CREATE TRIGGER athena_add_sim BEFORE INSERT ON public.\"Sims\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_sim();"
  },
  {
    "tgname": "athena_add_spellinfo",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_spellinfo() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_spellinfo() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_spellinfo() IS 'Додавання інформації по зміні'; CREATE TRIGGER athena_add_spellinfo BEFORE INSERT ON public.\"SpellInfos\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_spellinfo();"
  },
  {
    "tgname": "athena_add_street",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_street() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_street() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_street() IS 'Додавання вулиці'; CREATE TRIGGER athena_add_street BEFORE INSERT ON public.\"Streets\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_street();"
  },
  {
    "tgname": "athena_add_streettype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_streettype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_streettype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_streettype() IS 'Додавання типу вулиці'; CREATE TRIGGER athena_add_streettype BEFORE INSERT ON public.\"StreetTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_streettype();"
  },
  {
    "tgname": "athena_add_tag",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_tag() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_tag() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_tag() IS 'Додавання тегу'; CREATE TRIGGER athena_add_tag BEFORE INSERT ON public.\"Tags\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_tag();"
  },
  {
    "tgname": "athena_add_tagtosession",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_tagtosession() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_tagtosession() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_tagtosession() IS 'Додавання звязку між сеансом та тегами'; CREATE TRIGGER athena_add_tagtosession BEFORE INSERT ON public.\"TagToSessions\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_tagtosession();"
  },
  {
    "tgname": "athena_add_typeofimportance",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_typeofimportance() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_typeofimportance() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_typeofimportance() IS 'Додавання типу важливості'; CREATE TRIGGER athena_add_typeofimportance BEFORE INSERT ON public.\"TypesOfImportance\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_typeofimportance();"
  },
  {
    "tgname": "athena_add_workarea",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_workarea() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_workarea() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_workarea() IS 'Додавання території роботи'; CREATE TRIGGER athena_add_workarea BEFORE INSERT ON public.\"WorkAreas\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_workarea();"
  },
  {
    "tgname": "athena_add_workline",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_workline() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_workline() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_workline() IS 'Додавання лінії роботи'; CREATE TRIGGER athena_add_workline BEFORE INSERT ON public.\"WorkLines\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_workline();"
  },
  {
    "tgname": "athena_add_workplace",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_add_workplace() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = current_timestamp; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_add_workplace() OWNER TO postgres; COMMENT ON FUNCTION public.athena_add_workplace() IS 'Додавання місця роботи'; CREATE TRIGGER athena_add_workplace BEFORE INSERT ON public.\"WorkPlace\" FOR EACH ROW EXECUTE PROCEDURE public.athena_add_workplace();"
  },
  {
    "tgname": "athena_upd_address",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_address() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_address() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_address() IS 'Модифікація адреси'; CREATE TRIGGER athena_upd_address BEFORE UPDATE ON public.\"Addresses\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_address();"
  },
  {
    "tgname": "athena_upd_addresstype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_addresstype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_addresstype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_addresstype() IS 'Модифікація типу адреси'; CREATE TRIGGER athena_upd_addresstype BEFORE UPDATE ON public.\"AddressTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_addresstype();"
  },
  {
    "tgname": "athena_upd_basestation",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_basestation() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_basestation() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_basestation() IS 'Модифікація базових станцій'; CREATE TRIGGER athena_upd_basestation BEFORE UPDATE ON public.\"BaseStations\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_basestation();"
  },
  {
    "tgname": "athena_upd_blanktype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_blanktype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_blanktype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_blanktype() IS 'Модифікація типу бланку'; CREATE TRIGGER athena_upd_blanktype BEFORE UPDATE ON public.\"BlankTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_blanktype();"
  },
  {
    "tgname": "athena_upd_casetype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_casetype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_casetype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_casetype() IS 'Модифікація типу справ'; CREATE TRIGGER athena_upd_casetype BEFORE UPDATE ON public.\"CaseTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_casetype();"
  },
  {
    "tgname": "athena_upd_codexarticle",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_codexarticle() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_codexarticle() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_codexarticle() IS 'Модифікація статті ККУ'; CREATE TRIGGER athena_upd_codexarticle BEFORE UPDATE ON public.\"CodexArticles\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_codexarticle();"
  },
  {
    "tgname": "athena_upd_codexpart",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_codexpart() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_codexpart() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_codexpart() IS 'Модифікація розділів ККУ'; CREATE TRIGGER athena_upd_codexpart BEFORE UPDATE ON public.\"CodexParts\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_codexpart();"
  },
  {
    "tgname": "athena_upd_codexsubarticle",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_codexsubarticle() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_codexsubarticle() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_codexsubarticle() IS 'Модифікація частини статі ККУ'; CREATE TRIGGER athena_upd_codexsubarticle BEFORE UPDATE ON public.\"CodexSubArticles\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_codexsubarticle();"
  },
  {
    "tgname": "athena_upd_communicationcomplex",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_communicationcomplex() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_communicationcomplex() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_communicationcomplex() IS 'Модифікація комплексу'; CREATE TRIGGER athena_upd_communicationcomplex BEFORE UPDATE ON public.\"CommunicationComplexes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_communicationcomplex();"
  },
  {
    "tgname": "athena_upd_communicationtype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_communicationtype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_communicationtype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_communicationtype() IS 'Модифікація типу звязку'; CREATE TRIGGER athena_upd_communicationtype BEFORE UPDATE ON public.\"CommunicationTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_communicationtype();"
  },
  {
    "tgname": "athena_upd_courtorder",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_courtorder() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_courtorder() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_courtorder() IS 'Модифікація ухвали суду'; CREATE TRIGGER athena_upd_courtorder BEFORE UPDATE ON public.\"CourtOrders\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_courtorder();"
  },
  {
    "tgname": "athena_upd_crime",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_crime() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_crime() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_crime() IS 'Модифікація злочину'; CREATE TRIGGER athena_upd_crime BEFORE UPDATE ON public.\"Crimes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_crime();"
  },
  {
    "tgname": "athena_upd_crimetocodex",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_crimetocodex() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_crimetocodex() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_crimetocodex() IS 'Модифікація зв’язоку Злочин - Стаття ККУ'; CREATE TRIGGER athena_upd_crimetocodex BEFORE UPDATE ON public.\"CrimeToCodex\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_crimetocodex();"
  },
  {
    "tgname": "athena_upd_department",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_department() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_department() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_department() IS 'Модифікація підрозділу'; CREATE TRIGGER athena_upd_department BEFORE UPDATE ON public.\"Departments\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_department();"
  },
  {
    "tgname": "athena_upd_district",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_district() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_district() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_district() IS 'Модифікація району'; CREATE TRIGGER athena_upd_district BEFORE UPDATE ON public.\"Districts\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_district();"
  },
  {
    "tgname": "athena_upd_document",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_document() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_document() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_document() IS 'Модифікація документу'; CREATE TRIGGER athena_upd_document BEFORE UPDATE ON public.\"Documents\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_document();"
  },
  {
    "tgname": "athena_upd_documenttype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_documenttype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_documenttype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_documenttype() IS 'Модифікація типу документа'; CREATE TRIGGER athena_upd_documenttype BEFORE UPDATE ON public.\"DocumentTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_documenttype();"
  },
  {
    "tgname": "athena_upd_email",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_email() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_email() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_email() IS 'Модифікація E-mail'; CREATE TRIGGER athena_upd_email BEFORE UPDATE ON public.\"Emails\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_email();"
  },
  {
    "tgname": "athena_upd_eventtypeone",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_eventtypeone() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_eventtypeone() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_eventtypeone() IS 'Модифікація типу захода 1'; CREATE TRIGGER athena_upd_eventtypeone BEFORE UPDATE ON public.\"EventTypesOne\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_eventtypeone();"
  },
  {
    "tgname": "athena_upd_eventtypetwo",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_eventtypetwo() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_eventtypetwo() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_eventtypetwo() IS 'Модифікація типу захода 2'; CREATE TRIGGER athena_upd_eventtypetwo BEFORE UPDATE ON public.\"EventTypesTwo\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_eventtypetwo();"
  },
  {
    "tgname": "athena_upd_htmltemplate",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_htmltemplate() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_htmltemplate() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_htmltemplate() IS 'Модифікація шаблону заявки'; CREATE TRIGGER athena_upd_htmltemplate BEFORE UPDATE ON public.\"HtmlTemplates\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_htmltemplate();"
  },
  {
    "tgname": "athena_upd_imei",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_imei() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_imei() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_imei() IS 'Модифікація IMEI'; CREATE TRIGGER athena_upd_imei BEFORE UPDATE ON public.\"Imeis\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_imei();"
  },
  {
    "tgname": "athena_upd_importerservice",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_importerservice() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_importerservice() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_importerservice() IS 'Модифікація імпортеру'; CREATE TRIGGER athena_upd_importerservice BEFORE UPDATE ON public.\"ImporterServices\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_importerservice();"
  },
  {
    "tgname": "athena_upd_initiatortoissue",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_initiatortoissue() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_initiatortoissue() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_initiatortoissue() IS 'Модифікація зв’язоку Ініціатор - Завдання'; CREATE TRIGGER athena_upd_initiatortoissue BEFORE UPDATE ON public.\"InitiatorToIssues\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_initiatortoissue();"
  },
  {
    "tgname": "athena_upd_initiatorrank",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_initiatorrank() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_initiatorrank() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_initiatorrank() IS 'Модифікація рангів ініціатора сеансу'; CREATE TRIGGER athena_upd_initiatorrank BEFORE UPDATE ON public.\"InitiatorRanks\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_initiatorrank();"
  },
  {
    "tgname": "athena_upd_interlocutor",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_interlocutor() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_interlocutor() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_interlocutor() IS 'Модифікація співрозмовника'; CREATE TRIGGER athena_upd_interlocutor BEFORE UPDATE ON public.\"Interlocutors\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_interlocutor();"
  },
  {
    "tgname": "athena_upd_investigationresult",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_investigationresult() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_investigationresult() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_investigationresult() IS 'Модифікація результату розслідування'; CREATE TRIGGER athena_upd_investigationresult BEFORE UPDATE ON public.\"InvestigationResults\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_investigationresult();"
  },
  {
    "tgname": "athena_upd_issue",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_issue() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_issue() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_issue() IS 'Модифікація завдання'; CREATE TRIGGER athena_upd_issue BEFORE UPDATE ON public.\"Issues\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_issue();"
  },
  {
    "tgname": "athena_upd_issuecode",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_issuecode() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_issuecode() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_issuecode() IS 'Модифікація коду завдання'; CREATE TRIGGER athena_upd_issuecode BEFORE UPDATE ON public.\"IssueCodes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_issuecode();"
  },
  {
    "tgname": "athena_upd_issuestatus",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_issuestatus() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_issuestatus() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_issuestatus() IS 'Модифікація статусу завдання'; CREATE TRIGGER athena_upd_issuestatus BEFORE UPDATE ON public.\"IssueStatuses\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_issuestatus();"
  },
  {
    "tgname": "athena_upd_issuestatushistory",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_issuestatushistory() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_issuestatushistory() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_issuestatushistory() IS 'Модифікація історії статусів завдань'; CREATE TRIGGER athena_upd_issuestatushistory BEFORE UPDATE ON public.\"IssueStatusHistories\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_issuestatushistory();"
  },
  {
    "tgname": "athena_upd_issuestatustoassignment",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_issuestatustoassignment() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_issuestatustoassignment() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_issuestatustoassignment() IS 'Модифікація статусів завдань для розподілу'; CREATE TRIGGER athena_upd_issuestatustoassignment BEFORE UPDATE ON public.\"IssueStatusToAssignments\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_issuestatustoassignment();"
  },
  {
    "tgname": "athena_upd_locality",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_locality() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_locality() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_locality() IS 'Модифікація населеного пункту'; CREATE TRIGGER athena_upd_locality BEFORE UPDATE ON public.\"Localities\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_locality();"
  },
  {
    "tgname": "athena_upd_localitytype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_localitytype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_localitytype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_localitytype() IS 'Модифікація типу населеного пункту'; CREATE TRIGGER athena_upd_localitytype BEFORE UPDATE ON public.\"LocalityTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_localitytype();"
  },
  {
    "tgname": "athena_upd_mobileoperator",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_mobileoperator() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_mobileoperator() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_mobileoperator() IS 'Модифікація оператора звязку'; CREATE TRIGGER athena_upd_mobileoperator BEFORE UPDATE ON public.\"MobileOperators\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_mobileoperator();"
  },
  {
    "tgname": "athena_upd_nationality",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_nationality() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_nationality() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_nationality() IS 'Модифікація громадянства'; CREATE TRIGGER athena_upd_nationality BEFORE UPDATE ON public.\"Nationalities\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_nationality();"
  },
  {
    "tgname": "athena_upd_organization",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_organization() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_organization() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_organization() IS 'Модифікація організації'; CREATE TRIGGER athena_upd_organization BEFORE UPDATE ON public.\"Organizations\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_organization();"
  },
  {
    "tgname": "athena_upd_parsesetting",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_parsesetting() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_parsesetting() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_parsesetting() IS 'Модифікація налаштування парсингу'; CREATE TRIGGER athena_upd_parsesetting BEFORE UPDATE ON public.\"ParseSettings\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_parsesetting();"
  },
  {
    "tgname": "athena_upd_person",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_person() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_person() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_person() IS 'Модифікація персони'; CREATE TRIGGER athena_upd_person BEFORE UPDATE ON public.\"Persons\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_person();"
  },
  {
    "tgname": "athena_upd_personalias",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_personalias() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_personalias() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_personalias() IS 'Модифікація прізвиська'; CREATE TRIGGER athena_upd_personalias BEFORE UPDATE ON public.\"PersonAliases\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_personalias();"
  },
  {
    "tgname": "athena_upd_persontoimei",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_persontoimei() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_persontoimei() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_persontoimei() IS 'Модифікація звязку між персоной та IMEI'; CREATE TRIGGER athena_upd_persontoimei BEFORE UPDATE ON public.\"PersonToImeis\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_persontoimei();"
  },
  {
    "tgname": "athena_upd_persontoperson",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_persontoperson() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_persontoperson() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_persontoperson() IS 'Модифікація звязку між персонами'; CREATE TRIGGER athena_upd_persontoperson BEFORE UPDATE ON public.\"PersonToPeople\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_persontoperson();"
  },
  {
    "tgname": "athena_upd_persontosim",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_persontosim() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_persontosim() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_persontosim() IS 'Модифікація звязку між персоною та SIM'; CREATE TRIGGER athena_upd_persontosim BEFORE UPDATE ON public.\"PersonToSims\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_persontosim();"
  },
  {
    "tgname": "athena_upd_persontotag",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_persontotag() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_persontotag() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_persontotag() IS 'Модифікація звязку між персоною та тегами'; CREATE TRIGGER athena_upd_persontotag BEFORE UPDATE ON public.\"PersonToTags\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_persontotag();"
  },
  {
    "tgname": "athena_upd_position",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_position() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_position() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_position() IS 'Модифікація посади співробітників'; CREATE TRIGGER athena_upd_position BEFORE UPDATE ON public.\"Positions\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_position();"
  },
  {
    "tgname": "athena_upd_rank",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_rank() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_rank() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_rank() IS 'Модифікація спеціального звання'; CREATE TRIGGER athena_upd_rank BEFORE UPDATE ON public.\"Rank\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_rank();"
  },
  {
    "tgname": "athena_upd_region",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_region() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_region() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_region() IS 'Модифікація області'; CREATE TRIGGER athena_upd_region BEFORE UPDATE ON public.\"Regions\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_region();"
  },
  {
    "tgname": "athena_upd_session",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_session() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_session() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_session() IS 'Модифікація сеансу'; CREATE TRIGGER athena_upd_session BEFORE UPDATE ON public.\"Sessions\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_session();"
  },
  {
    "tgname": "athena_upd_sessiondescription",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_sessiondescription() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_sessiondescription() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_sessiondescription() IS 'Модифікація розшифрування сеансів'; CREATE TRIGGER athena_upd_sessiondescription BEFORE UPDATE ON public.\"SessionDescriptions\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_sessiondescription();"
  },
  {
    "tgname": "athena_upd_sessionrank",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_sessionrank() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_sessionrank() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_sessionrank() IS 'Модифікація рангів сеансу'; CREATE TRIGGER athena_upd_sessionrank BEFORE UPDATE ON public.\"SessionRanks\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_sessionrank();"
  },
  {
    "tgname": "athena_upd_sessionstatistic",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_sessionstatistic() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_sessionstatistic() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_sessionstatistic() IS 'Модифікація статистики за сеансами'; CREATE TRIGGER athena_upd_sessionstatistic BEFORE UPDATE ON public.\"SessionStatistic\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_sessionstatistic();"
  },
  {
    "tgname": "athena_upd_sessionstatus",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_sessionstatus() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_sessionstatus() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_sessionstatus() IS 'Модифікація статусу сеансу'; CREATE TRIGGER athena_upd_sessionstatus BEFORE UPDATE ON public.\"SessionStatus\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_sessionstatus();"
  },
  {
    "tgname": "athena_upd_sessionstatusinitiator",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_sessionstatusinitiator() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_sessionstatusinitiator() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_sessionstatusinitiator() IS 'Модифікація статусу сеансу ініціатора'; CREATE TRIGGER athena_upd_sessionstatusinitiator BEFORE UPDATE ON public.\"SessionStatusInitiators\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_sessionstatusinitiator();"
  },
  {
    "tgname": "athena_upd_sim",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_sim() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_sim() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_sim() IS 'Модифікація SIM'; CREATE TRIGGER athena_upd_sim BEFORE UPDATE ON public.\"Sims\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_sim();"
  },
  {
    "tgname": "athena_upd_spellinfo",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_spellinfo() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_spellinfo() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_spellinfo() IS 'Модифікація інформації по зміні'; CREATE TRIGGER athena_upd_spellinfo BEFORE UPDATE ON public.\"SpellInfos\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_spellinfo();"
  },
  {
    "tgname": "athena_upd_street",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_street() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_street() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_street() IS 'Модифікація вулиці'; CREATE TRIGGER athena_upd_street BEFORE UPDATE ON public.\"Streets\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_street();"
  },
  {
    "tgname": "athena_upd_streettype",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_streettype() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_streettype() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_streettype() IS 'Модифікація типу вулиці'; CREATE TRIGGER athena_upd_streettype BEFORE UPDATE ON public.\"StreetTypes\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_streettype();"
  },
  {
    "tgname": "athena_upd_tag",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_tag() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_tag() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_tag() IS 'Модифікація тегу'; CREATE TRIGGER athena_upd_tag BEFORE UPDATE ON public.\"Tags\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_tag();"
  },
  {
    "tgname": "athena_upd_tagtosession",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_tagtosession() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_tagtosession() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_tagtosession() IS 'Модифікація звязку між сеансом та тегами'; CREATE TRIGGER athena_upd_tagtosession BEFORE UPDATE ON public.\"TagToSessions\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_tagtosession();"
  },
  {
    "tgname": "athena_upd_typeofimportance",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_typeofimportance() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_typeofimportance() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_typeofimportance() IS 'Модифікація типу важливості'; CREATE TRIGGER athena_upd_typeofimportance BEFORE UPDATE ON public.\"TypesOfImportance\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_typeofimportance();"
  },
  {
    "tgname": "athena_upd_workarea",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_workarea() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_workarea() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_workarea() IS 'Модифікація території роботи'; CREATE TRIGGER athena_upd_workarea BEFORE UPDATE ON public.\"WorkAreas\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_workarea();"
  },
  {
    "tgname": "athena_upd_workline",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_workline() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_workline() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_workline() IS 'Модифікація лінії роботи'; CREATE TRIGGER athena_upd_workline BEFORE UPDATE ON public.\"WorkLines\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_workline();"
  },
  {
    "tgname": "athena_upd_workplace",
    "sql": "CREATE OR REPLACE FUNCTION public.athena_upd_workplace() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $BODY$ BEGIN NEW.\"CreatedOn\" = OLD.\"CreatedOn\"; NEW.\"UpdatedOn\" = current_timestamp; RETURN NEW; END; $BODY$; ALTER FUNCTION public.athena_upd_workplace() OWNER TO postgres; COMMENT ON FUNCTION public.athena_upd_workplace() IS 'Модифікація місця роботи'; CREATE TRIGGER athena_upd_workplace BEFORE UPDATE ON public.\"WorkPlace\" FOR EACH ROW EXECUTE PROCEDURE public.athena_upd_workplace();"
  }
]
